<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed Copy to Clipboard</title>
</head>
<body>
    <textarea id="text1" readonly>
graph = {
    '5': ['3', '7'],
    '3': ['2', '4'],
    '7': ['8'],
    '2': [],
    '4': ['8'],
    '8': []
}

visited = set()  # Set to keep track of visited nodes

def dfs(visited, graph, node):
    if node not in visited:
        print(node, end=" ")   # Print current node
        visited.add(node)
        for neighbour in graph[node]:
            dfs(visited, graph, neighbour)

print("Following is the Depth-First Search:")
dfs(visited, graph, '5')

</textarea>
    <button onclick="copyToClipboard('text1', this)">DFS</button>

    <textarea id="text2" readonly>
graph = {
    '5': ['3', '7'],
    '3': ['2', '4'],
    '7': ['8'],
    '2': [],
    '4': ['8'],
    '8': []
}

visited = []  # List to keep track of visited nodes
queue = []    # Initialize a queue

def bfs(visited, graph, node):
    visited.append(node)
    queue.append(node)

    while queue:
        m = queue.pop(0)
        print(m, end=" ")

        for neighbour in graph[m]:
            if neighbour not in visited:
                visited.append(neighbour)
                queue.append(neighbour)

print("Following is the Breadth-First Search:")
bfs(visited, graph, '5')

</textarea>
    <button onclick="copyToClipboard('text2', this)">BFS</button>

<textarea id="text3" readonly>
print("****** TOWER OF HANOI ******")

def moveTower(height, fromPole, toPole, withPole):
    if height >= 1:
        moveTower(height - 1, fromPole, withPole, toPole)
        moveDisk(fromPole, toPole)
        moveTower(height - 1, withPole, toPole, fromPole)

def moveDisk(fp, tp):
    print("Moving disk from", fp, "to", tp)

# Take user input for number of disks and pegs
num_disks = int(input("Enter the number of disks: "))
num_pegs = int(input("Enter the number of pegs: "))

# Validate peg input
if num_pegs < 3:
    print("At least 3 pegs are required. Exiting.")
else:
    if num_pegs > 3:
        print("\nNote: The current logic handles only 3 pegs. Extra pegs will be ignored.\n")
    
    print("------------------------")
    print(f"****** For {num_disks} Disks ******")
    print("------------------------")
    moveTower(num_disks, "A", "C", "B")

</textarea>
    <button onclick="copyToClipboard('text3', this)">TOHanoi</button>

<textarea id="text4" readonly>
print("****** TIC-TAC-TOE 4x4 (3 Players) ******")

import os
import time

board = [' '] * 17  # Using index 1–16
player = 1

######### Game Status ##########
Win = 1
Draw = -1
Running = 0
Game = Running
################################

# Draw the 4x4 board
def DrawBoard():
    print(" %c | %c | %c | %c " % (board[1], board[2], board[3], board[4]))
    print("___|___|___|___")
    print(" %c | %c | %c | %c " % (board[5], board[6], board[7], board[8]))
    print("___|___|___|___")
    print(" %c | %c | %c | %c " % (board[9], board[10], board[11], board[12]))
    print("___|___|___|___")
    print(" %c | %c | %c | %c " % (board[13], board[14], board[15], board[16]))
    print("   |   |   |   ")


# Check if a position is empty
def CheckPosition(x):
    return board[x] == ' '


# Check win conditions
def CheckWin():
    global Game

    # Horizontal wins
    for i in [1, 5, 9, 13]:
        if board[i] == board[i + 1] == board[i + 2] == board[i + 3] != ' ':
            Game = Win
            return

    # Vertical wins
    for i in range(1, 5):
        if board[i] == board[i + 4] == board[i + 8] == board[i + 12] != ' ':
            Game = Win
            return

    # Diagonal left-to-right
    if board[1] == board[6] == board[11] == board[16] != ' ':
        Game = Win
        return

    # Diagonal right-to-left
    if board[4] == board[7] == board[10] == board[13] != ' ':
        Game = Win
        return

    # Draw condition
    if all(cell != ' ' for cell in board[1:]):
        Game = Draw
    else:
        Game = Running


print("Tic-Tac-Toe Game")
print("Player 1 [$] --- Player 2 [&] --- Player 3 [*]\n")
print("Please Wait...")
time.sleep(1)

while Game == Running:
    os.system('cls' if os.name == 'nt' else 'clear')
    DrawBoard()

    if player % 3 == 1:
        print("Player 1's turn ($)")
        Mark = '$'
    elif player % 3 == 2:
        print("Player 2's turn (&)")
        Mark = '&'
    else:
        print("Player 3's turn (*)")
        Mark = '*'

    try:
        choice = int(input("Enter position [1-16]: "))
        if 1 <= choice <= 16:
            if CheckPosition(choice):
                board[choice] = Mark
                player += 1
                CheckWin()
            else:
                print("Position already taken. Try again.")
                time.sleep(1)
        else:
            print("Invalid input. Choose between 1 and 16.")
            time.sleep(1)
    except ValueError:
        print("Invalid input. Enter a number.")
        time.sleep(1)

# Final board display
os.system('cls' if os.name == 'nt' else 'clear')
DrawBoard()

# Result
if Game == Draw:
    print("Game Draw!")
elif Game == Win:
    player -= 1
    if player % 3 == 1:
        print("Player 1 ($) Won!")
    elif player % 3 == 2:
        print("Player 2 (&) Won!")
    else:
        print("Player 3 (*) Won!")

</textarea>
    <button onclick="copyToClipboard('text4', this)">TicTac</button>

<textarea id="text5" readonly>
import pandas as pd
import numpy as np
from io import StringIO
import io
from google.colab import files
uploaded = files.upload()

data = pd.read_csv(io.BytesIO(uploaded['ML Data.csv']))
print(data)

d = np.array(data)[:, :-1]
print("The attributes are: ", d)

target = np.array(data)[:, -1]
print("The target is: ", target)

def train(d, t):
    specific_hypothesis = d[0].copy()  # Initialize with the first example
    for i, val in enumerate(d):
        # Handle potential whitespace and case variations
        target_val = str(t[i]).strip().lower()
        if target_val == "yes":
            for x in range(len(specific_hypothesis)):
                if val[x] != specific_hypothesis[x]:
                    specific_hypothesis[x] = '?'
        elif target_val == "yes":  # Redundant condition
            for x in range(len(specific_hypothesis)):
                if val[x] != specific_hypothesis[x]:
                    specific_hypothesis[x] = '?'

    return specific_hypothesis

print("The final hypothesis is: ", train(d, target))

</textarea>
    <button onclick="copyToClipboard('text5', this)">s-algo For Hypothesis</button>

<textarea id="text6" readonly>
# Program: Random Forest Classifier on Iris Dataset
from sklearn.datasets import load_iris
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
import pandas as pd
import numpy as np

print("03_Tanmay Gujar")

# Load dataset
iris = load_iris()
df = pd.DataFrame(iris.data, columns=iris.feature_names)

# Add target labels
df['species'] = pd.Categorical.from_codes(iris.target, iris.target_names)

# Randomly assign training and testing data
df['is_train'] = np.random.uniform(0, 1, len(df)) <= 0.75

# Split dataset
train, test = df[df['is_train'] == True], df[df['is_train'] == False]
print('No. of observations in the training data:', len(train))
print('No. of observations in the testing data:', len(test))

# Define features and target
features = df.columns[:4]
y = pd.factorize(train['species'])[0]

# Train Random Forest model
clf = RandomForestClassifier(n_jobs=2, random_state=0)
clf.fit(train[features], y)

# Make predictions
preds = iris.target_names[clf.predict(test[features])]

# Compare predicted and actual values
print("\n--- Prediction Results ---")
print("First 5 Predictions:", preds[0:5])
print("Actual:", test['species'].head().values)

# Confusion matrix and classification report
print("\n--- Confusion Matrix ---")
print(confusion_matrix(test['species'], preds))

print("\n--- Classification Report ---")
print(classification_report(test['species'], preds))

# Accuracy score
print('The accuracy score is:', accuracy_score(test['species'], preds))

</textarea>
    <button onclick="copyToClipboard('text6', this)">decision/Random</button>

<textarea id="text7" readonly>
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Set default figure size
plt.rcParams['figure.figsize'] = (12.0, 9.0)

# Load dataset
data = pd.read_csv(r'C:\Users\Pranita\Downloads\data.csv')  # use raw string

# Extract X and Y
X = data.iloc[:, 0]
Y = data.iloc[:, 1]

# Scatter plot of original data
plt.scatter(X, Y, label='Actual Data')
plt.xlabel('X')
plt.ylabel('Y')
plt.title('Scatter Plot of Data')
plt.show()

# Calculate means
X_mean = np.mean(X)
Y_mean = np.mean(Y)

# Calculate slope (m) and intercept (c) manually
num = 0
den = 0
for i in range(len(X)):
    num += (X[i] - X_mean) * (Y[i] - Y_mean)
    den += (X[i] - X_mean)**2

m = num / den
c = Y_mean - m * X_mean

print("Slope (m):", m)
print("Intercept (c):", c)

# Predicted values
Y_pred = m * X + c

# Plotting original data and regression line
plt.scatter(X, Y, label='Actual Data')
plt.plot(X, Y_pred, color='red', label='Regression Line')
plt.xlabel('X')
plt.ylabel('Y')
plt.title('Linear Regression Fit')
plt.legend()
plt.show()

</textarea>
    <button onclick="copyToClipboard('text7', this)">least square</button>

<textarea id="text8" readonly>
# Program: K-Nearest Neighbors on Iris Dataset
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
from sklearn import datasets

print("03_Tanmay Gujar")

# Load Iris dataset
iris = datasets.load_iris()
iris_data = iris.data
iris_labels = iris.target

# Split dataset into train and test (80%-20%)
x_train, x_test, y_train, y_test = train_test_split(
    iris_data, iris_labels, test_size=0.20, random_state=42
)

# Create KNN classifier with k=13
classifier = KNeighborsClassifier(n_neighbors=13)
classifier.fit(x_train, y_train)

# Predict on test set
y_pred = classifier.predict(x_test)

# Evaluation
print("\n--- Classification Report ---")
print(classification_report(y_test, y_pred))

print("\n--- Confusion Matrix ---")
print(confusion_matrix(y_test, y_pred))

print("\nAccuracy Score:", accuracy_score(y_test, y_pred))

</textarea>
    <button onclick="copyToClipboard('text8', this)">k-nearest</button>

<textarea id="text9" readonly>
# rootx+y=7 rooty+x=11

import numpy as np
from scipy.optimize import fsolve

# Define the system of equations
def equations(vars):
    x, y = vars
    eq1 = np.sqrt(x) + y - 7
    eq2 = np.sqrt(y) + x - 11
    return [eq1, eq2]

# Solve the system with an initial guess
start_point = [1, 1]
solution = fsolve(equations, start_point)
x_sol, y_sol = solution

print("Question 1 Solution:")
print(f"Solution for x: {x_sol:.4f}")
print(f"Solution for y: {y_sol:.4f}")

</textarea>
    <button onclick="copyToClipboard('text9', this)">7q1</button>

<textarea id="text10" readonly>
print("\n ABCD x 4 = DBCA")

# 'a' and 'd' are fixed from the problem statement
a = 2
d = 8

# Try all possible values of b and c (0–9)
for b in range(10):
    for c in range(10):
        # Number ABCD
        abcd = a*1000 + b*100 + c*10 + d
        # Number DBCA
        dbca = d*1000 + b*100 + c*10 + a
        if abcd * 4 == dbca:
            print(f"a = {a}, b = {b}, c = {c}, d = {d}")
            print(f"Verification: {abcd} * 4 = {abcd*4}, DBCA = {dbca}")
            break
    else:
        continue
    break

</textarea>
    <button onclick="copyToClipboard('text10', this)">7q2</button>


    <script>
        function copyToClipboard(elementId, button) {
            let textElement = document.getElementById(elementId);
            navigator.clipboard.writeText(textElement.value).then(() => {
                let originalText = button.innerText;
                button.innerText = "Copied!";
                setTimeout(() => {
                    button.innerText = originalText;
                }, 1500);
            }).catch(err => {
                console.error("Failed to copy: ", err);
            });
        }
    </script>
</body>
</html>
