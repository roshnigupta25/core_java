<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed Copy to Clipboard</title>
</head>
<body>
    <textarea id="text1" readonly>
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract LogicalOperators {

    // Function to test Logical Operators
    function testLogicalOperators(bool a, bool b)
        public
        pure
        returns (
            bool logicalAnd,
            bool logicalOr,
            bool logicalNotB
        )
    {
        logicalAnd = a && b;   // Logical AND
        logicalOr = a || b;    // Logical OR
        logicalNotB = !b;      // Logical NOT of b

        return (logicalAnd, logicalOr, logicalNotB);
    }
}

</textarea>
    <button onclick="copyToClipboard('text1', this)">Crete lockchain Logical operator</button>

    <textarea id="text2" readonly>
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract IncDec {

    uint256 public number;   // State variable

    // Set initial value
    function setNumber(uint256 _num) public {
        number = _num;
    }

    // Increment using ++ operator
    function increment() public {
        number++;   // same as number = number + 1
    }

    // Decrement using -- operator
    function decrement() public {
        require(number > 0, "Error: Number cannot be negative");
        number--;   // same as number = number - 1
    }

    // Return current value
    function getNumber() public view returns (uint256) {
        return number;
    }
}

</textarea>
    <button onclick="copyToClipboard('text2', this)">Increment Derement Operator</button>

    <textarea id="text30" readonly>
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Calculator {

    function calculate(uint256 a, uint256 b)
        public
        pure
        returns (
            uint256 sum,
            uint256 difference,
            uint256 product,
            uint256 quotient
        )
    {
        sum = a + b;
        difference = a - b;
        product = a * b;

        require(b > 0, "Error: Division by zero is not allowed.");

        quotient = a / b;
    }
}


</textarea>
    <button onclick="copyToClipboard('text30', this)">  All the results must be clubbed together in one single method / function</button>

<textarea id="text3" readonly>
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract OperatorExamples {

    // State variables
    uint public numberA = 10;
    uint public numberB = 5;
    bool public flagA = true;
    bool public flagB = false;

    // A) LOGICAL OPERATORS (&&, ||, !)
    function logicalOps()
        public
        view
        returns (bool, bool, bool)
    {
        bool andResult = flagA && flagB;
        bool orResult  = flagA || flagB;
        bool notResult = !flagA;

        return (andResult, orResult, notResult);
    }

    // B) BITWISE OPERATORS
    function bitwiseOps()
        public
        view
        returns (uint, uint, uint, uint, uint, uint)
    {
        uint andResult = numberA & numberB;   // Bitwise AND
        uint orResult  = numberA | numberB;   // Bitwise OR
        uint xorResult = numberA ^ numberB;   // Bitwise XOR
        uint notResult = ~numberA;            // Bitwise NOT
        uint shiftL    = numberA << 1;        // Left shift
        uint shiftR    = numberA >> 1;        // Right shift

        return (andResult, orResult, xorResult, notResult, shiftL, shiftR);
    }

    // C) ASSIGNMENT OPERATORS
    function assignmentOps() public {
        numberA = 10;     // assignment
        numberA += 5;     // numberA = numberA + 5
        numberA -= 3;     // numberA = numberA - 3
        numberA *= 2;     // numberA = numberA * 2
        numberA /= 4;     // numberA = numberA / 4
    }

    // D) COMPARISON OPERATORS
    function comparisonOps()
        public
        view
        returns (bool, bool, bool, bool, bool, bool)
    {
        bool eq  = (numberA == numberB);  // Equal
        bool neq = (numberA != numberB);  // Not equal
        bool gte = (numberA >= numberB);  // Greater than or equal
        bool lte = (numberA <= numberB);  // Less than or equal
        bool gt  = (numberA > numberB);   // Greater than
        bool lt  = (numberA < numberB);   // Less than

        return (eq, neq, gte, lte, gt, lt);
    }
}


</textarea>
    <button onclick="copyToClipboard('text3', this)"> Logical,Bitwise,Assignment,Comparison</button>

<textarea id="text4" readonly>
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DOBOperations {

    uint public DD;
    uint public MM;
    uint public YY;

    uint public num1;              // DD & MM
    uint public num2;              // YY | YY (same as YY)

    uint public addition;
    uint public additionMod;

    uint public multiplication;
    uint public multiplicationMod;

    // Pass your date of birth as parameters
    constructor(uint _DD, uint _MM, uint _YY) {

        DD = _DD;
        MM = _MM;
        YY = _YY;

        // Step 1: Perform AND and OR
        num1 = DD & MM;
        num2 = YY | YY;

        // Step 2: Addition and modulus with DD
        addition = num1 + num2;
        additionMod = addition % DD;

        // Step 3: Multiplication and modulus with MM
        multiplication = num1 * num2;
        multiplicationMod = multiplication % MM;
    }

    // Function to recompute (optional)
    function recompute() public {

        num1 = DD & MM;
        num2 = YY | YY;

        addition = num1 + num2;
        additionMod = addition % DD;

        multiplication = num1 * num2;
        multiplicationMod = multiplication % MM;
    }
}

</textarea>
    <button onclick="copyToClipboard('text4', this)">DOB</button>

<textarea id="text5" readonly>
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract OverloadingOperations {

    // ================= ADDITION =================
    function add(uint a, uint b) public pure returns(uint) {
        return a + b;
    }

    function add(uint a, uint b, uint c) public pure returns(uint) {
        return a + b + c;
    }

    function add(uint a, uint b, uint c, uint d) public pure returns(uint) {
        return a + b + c + d;
    }

    // ================= SUBTRACTION =================
    function sub(uint a, uint b) public pure returns(uint) {
        return a - b;
    }

    function sub(uint a, uint b, uint c) public pure returns(uint) {
        return a - b - c;
    }

    function sub(uint a, uint b, uint c, uint d) public pure returns(uint) {
        return a - b - c - d;
    }

    // ================= MULTIPLICATION =================
    function mul(uint a, uint b) public pure returns(uint) {
        return a * b;
    }

    function mul(uint a, uint b, uint c) public pure returns(uint) {
        return a * b * c;
    }

    function mul(uint a, uint b, uint c, uint d) public pure returns(uint) {
        return a * b * c * d;
    }

    // ================= BITWISE AND =================
    function bitAnd(uint a, uint b) public pure returns(uint) {
        return a & b;
    }

    function bitAnd(uint a, uint b, uint c) public pure returns(uint) {
        return a & b & c;
    }

    function bitAnd(uint a, uint b, uint c, uint d) public pure returns(uint) {
        return a & b & c & d;
    }

    // ================= BITWISE OR =================
    function bitOr(uint a, uint b) public pure returns(uint) {
        return a | b;
    }

    function bitOr(uint a, uint b, uint c) public pure returns(uint) {
        return a | b | c;
    }

    function bitOr(uint a, uint b, uint c, uint d) public pure returns(uint) {
        return a | b | c | d;
    }

    // ================= LOGICAL AND =================
    function logicalAnd(bool a, bool b) public pure returns(bool) {
        return a && b;
    }

    function logicalAnd(bool a, bool b, bool c) public pure returns(bool) {
        return a && b && c;
    }

    function logicalAnd(bool a, bool b, bool c, bool d) public pure returns(bool) {
        return a && b && c && d;
    }

    // ================= LOGICAL OR =================
    function logicalOr(bool a, bool b) public pure returns(bool) {
        return a || b;
    }

    function logicalOr(bool a, bool b, bool c) public pure returns(bool) {
        return a || b || c;
    }

    function logicalOr(bool a, bool b, bool c, bool d) public pure returns(bool) {
        return a || b || c || d;
    }
}

</textarea>
    <button onclick="copyToClipboard('text5', this)">Write a solidity program for overload the function for three numbers Addition,Subtraction Multiplication,bitwise And ,bitwise OR, logical And, logical OR write a solidity program  for 2 parameter, 3 parameter and 4 parameter</button>

<textarea id="text6" readonly>
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MaxMinLogic {

    // Function for 2 numbers
    function compute(uint a, uint b)
        public
        pure
        returns (uint result, bool condition)
    {
        uint maxVal = a > b ? a : b;
        uint minVal = a < b ? a : b;

        // Condition: max == min
        condition = (maxVal == minVal);

        if (condition) {
            result = a ^ b;   // XOR
        } else {
            result = a | b;   // OR
        }
    }

    // Function Overloading for 3 numbers
    function compute(uint a, uint b, uint c)
        public
        pure
        returns (uint result, bool condition)
    {
        uint maxVal = max(a, max(b, c));
        uint minVal = min(a, min(b, c));

        condition = (maxVal == minVal);

        if (condition) {
            result = a ^ b ^ c;   // XOR
        } else {
            result = a | b | c;   // OR
        }
    }

    // Helper function to find maximum
    function max(uint x, uint y)
        private
        pure
        returns (uint)
    {
        return x > y ? x : y;
    }

    // Helper function to find minimum
    function min(uint x, uint y)
        private
        pure
        returns (uint)
    {
        return x < y ? x : y;
    }
}

</textarea>
    <button onclick="copyToClipboard('text6', this)">Write a solidity program that checks whether the maximum of 2 numbers is equal to minimum of 2 numbers in case it is true then perform XOR operation and if it is false then perform OR operation overload the function to work for three numbers and apply the same condition |(Hint for true condition consider 8 and  4 and for three numbers  consider 2,3,4 and for false condition consider 6,10 and 6,3,12 for false.</button>

<textarea id="text7" readonly>
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AddProductCheck {

    // Function for 2 numbers
    function calculate(uint a, uint b)
        public
        pure
        returns (
            uint result,
            bool condition,
            uint addmodResult,
            uint mulmodResult
        )
    {
        // Check if addition equals product
        condition = (a + b == a * b);

        if (condition) {
            // If YES → AND operation
            result = a & b;
        } else {
            // If NO → OR operation
            result = a | b;
        }

        // Avoid modulo by 0
        uint safeMod = result == 0 ? 1 : result;

        // Perform addmod and mulmod
        addmodResult = addmod(a, b, safeMod);
        mulmodResult = mulmod(a, b, safeMod);
    }

    // Function Overloading for 3 numbers
    function calculate(uint a, uint b, uint c)
        public
        pure
        returns (
            uint result,
            bool condition,
            uint addmodResult,
            uint mulmodResult
        )
    {
        // Check if sum equals product
        condition = (a + b + c == a * b * c);

        if (condition) {
            // If YES → AND operation
            result = a & b & c;
        } else {
            // If NO → OR operation
            result = a | b | c;
        }

        // Avoid modulo by 0
        uint safeMod = result == 0 ? 1 : result;

        // Perform addmod and mulmod
        addmodResult = addmod(a + b, c, safeMod);
        mulmodResult = mulmod(a * b, c, safeMod);
    }
}

</textarea>
    <button onclick="copyToClipboard('text7', this)">Write a program in solidity to determine if addition of two numbers is equal to product of same two numbers if YES, then find AND operation of two numbers else find OR operation of two numbers & perform addmod & mulmod of the two numbers with the result.  Subsequently overload the function for three numbers. </button>

<textarea id="text8" readonly>
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PatkarVardeCollege {

    struct Student {
        string name;
        uint rollNumber;
        string class;
    }

    // Mapping to store students by roll number
    mapping(uint => Student) public students;

    // Array of classrooms (45 to 49)
    uint[] public classrooms = [45, 46, 47, 48, 49];

    // Constructor to initialize at least 10 students
    constructor() {
        students[1] = Student("Alice Johnson", 1, "Class A");
        students[2] = Student("Bob Smith", 2, "Class B");
        students[3] = Student("Charlie Brown", 3, "Class C");
        students[4] = Student("David Wilson", 4, "Class D");
        students[5] = Student("Eve Davis", 5, "Class E");
        students[6] = Student("Frank Miller", 6, "Class F");
        students[7] = Student("Grace Lee", 7, "Class G");
        students[8] = Student("Heidi Garcia", 8, "Class H");
        students[9] = Student("Ivan Martinez", 9, "Class I");
        students[10] = Student("Judy Anderson", 10, "Class J");
    }

    // Function to get the allocated classroom based on roll number
    // Allocation logic:
    // 1–5   → 45
    // 6–10  → 46
    // 11–15 → 47
    // 16–20 → 48
    // 21–25 → 49
    function getClassroom(uint rollNumber)
        public
        view
        returns (uint)
    {
        require(
            rollNumber >= 1 && rollNumber <= 25,
            "Invalid roll number: must be between 1 and 25"
        );

        uint index = (rollNumber - 1) / 5;
        return classrooms[index];
    }
}

</textarea>
    <button onclick="copyToClipboard('text8', this)">Smart contract</button>

<textarea id="text9" readonly>
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ArrayOperations {

    // Function to get approximate current month (1–12)
    function getCurrentMonth() public view returns (uint256) {

        uint256 secondsInMonth = 2629743;   // Avg seconds in month
        uint256 yearSeconds = 31536000;     // Approx seconds in year

        uint256 totalSeconds = block.timestamp % yearSeconds;

        uint256 month = (totalSeconds / secondsInMonth) + 1;

        if (month > 12) {
            month = 12;
        }

        return month;
    }

    // Function to perform required operations
    function performOperations()
        public
        view
        returns (uint256 modSum, uint256 modProduct)
    {
        // Create array of 10 numbers
        uint256;

        arr[0] = 10;
        arr[1] = 15;
        arr[2] = 20;
        arr[3] = 25;
        arr[4] = 30;
        arr[5] = 35;
        arr[6] = 40;
        arr[7] = 45;
        arr[8] = 50;
        arr[9] = 55;

        // Bitwise AND on odd indices (1,3,5,7,9)
        uint256 andResult =
            arr[1] &
            arr[3] &
            arr[5] &
            arr[7] &
            arr[9];

        // Bitwise OR on even indices (0,2,4,6,8)
        uint256 orResult =
            arr[0] |
            arr[2] |
            arr[4] |
            arr[6] |
            arr[8];

        // Check intermediate results
        if (andResult == 0 || orResult == 0) {
            revert("0 is not allowed");
        }

        // Addition & Multiplication
        uint256 sum = andResult + orResult;
        uint256 product = andResult * orResult;

        // Get current month
        uint256 month = getCurrentMonth();

        // Mod with month
        modSum = sum % month;
        modProduct = product % month;

        // Final zero check
        if (modSum == 0 || modProduct == 0) {
            revert("0 is not allowed");
        }

        return (modSum, modProduct);
    }
}

</textarea>
    <button onclick="copyToClipboard('text9', this)">Write a program in solidity to create an array of 10 number and find the AND  operation of 1,3 5,7, 9  position and ODD operation of 0,2,4,6,8 position and then perform addition and multiplication of the results and mod each one of them with the current month number.Also ensure that if any one number of any result is 0 then it should display the message 0 is not allowed.  </button>

<textarea id="text10" readonly>
 
</textarea>
    <button onclick="copyToClipboard('text10', this)">7 b. ABCD * 4</button>

<textarea id="text11" readonly>
 
</textarea>
    <button onclick="copyToClipboard('text11', this)">7 b. ABCD * 4</button>

    <textarea id="text12" readonly>
 
</textarea>
    <button onclick="copyToClipboard('text12', this)">7 b. ABCD * 4</button>

    <textarea id="text13" readonly>
 
</textarea>
    <button onclick="copyToClipboard('text13', this)">7 b. ABCD * 4</button>
    
    <script>
        function copyToClipboard(elementId, button) {
            let textElement = document.getElementById(elementId);
            navigator.clipboard.writeText(textElement.value).then(() => {
                let originalText = button.innerText;
                button.innerText = "Copied!";
                setTimeout(() => {
                    button.innerText = originalText;
                }, 1500);
            }).catch(err => {
                console.error("Failed to copy: ", err);
            });
        }
    </script>
</body>
</html>




